import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/data-fetching/event-loop-事件循环.md",collection="posts",slug="js/data-fetching/event-loop-事件循环",body="\n# Event Loop-事件循环\n\n## What is JavaScript?\n\n- [How JavaScript works](https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5 https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n- A **single-threaded** non-blocking asynchronous concurrent language.\n- 单线程、无阻塞、异步、并发\n- Have **a call stack**, an event loop, a callback queue and other APIs...\n\n### V8\n\n- A JS runtime\n- Have a callstack and a heap\n- The V8 can do one thing at a time, but not the browser which can access other APIs.\n\n## Event Loop (事件轮询机制)\n\n### macrotask 的本质\n\n[深入浏览器事件循环的本质 · Issue #160 · frontend9/fe9-library · GitHub](https://github.com/frontend9/fe9-library/issues/160)\n\n> macrotask 本质上是浏览器多个线程之间通信的一个消息队列  \n> 在 chrome 里，每个页面都对应一个进程，该进程又有多个线程，比如 js 线程、渲染线程、io 线程、网络线程、定时器线程等，这些线程之间的通信，是通过向对方的任务队列中添加一个任务（PostTask）来实现的。\n\n### Reference\n\n- ⭐[What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube](https://www.youtube.com/watch?v=8aGhZQkoFbQ)\n- ⭐[Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame, ... - YouTube](https://www.youtube.com/watch?v=cCOL7MC4Pl0)\n- [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872 https://juejin.cn/post/6844903512845860872)\n- [从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5 https://github.com/aooy/blog/issues/5)\n- [【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237 https://juejin.cn/post/6844903955286196237)\n- [一次弄懂 Event Loop（彻底解决此类面试问题）](https://juejin.cn/post/6844903764202094606 https://juejin.cn/post/6844903764202094606)\n- [深入理解 JavaScript Event Loop](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323 https://zhuanlan.zhihu.com/p/34229323)\n\n### Event Loop Execution Process\n\n- call stack > Web APIs > callback queue > 🔁event loop > task in callback queue? push task to the end of stack\n- 调用栈、堆栈溢出（stack overflow）、回调队列/任务队列（回调函数）、事件循环、\n- render queue：重绘\n\n  ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/Pasted-image-20221208182251.png)\n\n#### 事件轮询机制执行过程\n\n1）代码执行过程中，宏任务和微任务放在不同的任务队列中  \n2）当某个宏任务执行完后,会查看微任务队列是否有任务。如果有，执行微任务队列中的所有微任务 (注意这里是执行所有的微任务)  \n3）微任务执行完成后，会读取宏任务队列中排在最前的第一个宏任务（注意宏任务是一个个取），执行该宏任务，如果执行过程中，遇到微任务，依次加入微任务队列  \n4）宏任务执行完成后，再次读取微任务队列里的任务，依次类推。\n\n### 宏任务 微任务\n\n宏任务是一个个执行，执行一个宏任务，然后就把在任务队列中的所有微任务都执行完，再执行下一个宏任务，再执行所有微任务，依次类推\n\n### Reference\n\n- [Tasks, microtasks, queues and schedules](https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n- [详解宏任务、微任务与事件循环 Event Loop - 掘金](https://juejin.cn/post/7020710294083092493)\n\n### 宏任务（Macrotasks）\n\n主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务\n\n- script 全部代码（注意同步代码也属于宏任务）\n- setTimeout、setInterval、setImmediate 等\n\n### 微任务（Microtasks）\n\n不进入主线程、而进入 微任务列表 的任务\n\n- Promise、MutationObserver\n\n### Event loop 与 浏览器更新渲染时机\n\n1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即 `宏任务 → 微任务 → 渲染更新`（先宏任务 再微任务，然后再渲染更新）  \n2）宏任务队列中，如果有大量任务等待执行时，将 `dom的变动作为微任务，能更快的将变化呈现给用户`，这样就可以在这一次的事件轮询中更新 dom\n\n## `requestAnimationFrame`\n\n- [【今天你更博学了么】一个神奇的前端动画 API requestAnimationFrame - 掘金](https://juejin.cn/post/6991297852462858277?searchId=202402181438115229F57507550A5779CE)\n- [性能优化之通俗易懂学习 requestAnimationFrame 和使用场景举例 - 掘金](https://juejin.cn/post/7190728064458817591?searchId=202402181438115229F57507550A5779CE)\n- [另一种渲染大量数据的高效方法：requestAnimationFrame - 掘金](https://juejin.cn/post/7274346507037016104?searchId=202402181438115229F57507550A5779CE)\n- [利用 requestAnimationFrame 优化大数据列表渲染 - 掘金](https://juejin.cn/post/7262900590937063482?searchId=202402181438115229F57507550A5779CE)\n\n## 🛠️ Interview Exercise\n\n#### Event Loop 经典题目：判断打印结果\n\n```javascript\nPromise.resolve()\n\t.then(function () {\n\t\tconsole.log(promise0);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise5);\n\t});\nsetTimeout(() => {\n\tconsole.log(timer1);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise2);\n\t});\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise4);\n\t});\n}, 0);\nsetTimeout(() => {\n\tconsole.log(timer2);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise3);\n\t});\n}, 0);\nPromise.resolve().then(function () {\n\tconsole.log(promise1);\n});\nconsole.log(start);\n\n// 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3\n```\n\n#### 事件轮询执行时机\n\nasync 隐式返回 Promise，会产生一个微任务，await 后面的代码是在微任务时执行\n\n```javascript\nconsole.log(script start);\nasync function async1() {\n\tawait async2(); // await 隐式返回promise\n\tconsole.log(async1 end); // 这里的执行时机：在执行微任务时执行\n}\nasync function async2() {\n\tconsole.log(async2 end); // 这里是同步代码\n}\nasync1();\nsetTimeout(function () {\n\tconsole.log(setTimeout);\n}, 0);\nnew Promise((resolve) => {\n\tconsole.log(Promise); // 这里是同步代码\n\tresolve();\n})\n\t.then(function () {\n\t\tconsole.log(promise1);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise2);\n\t});\nconsole.log(script end);\n\n// 打印结果:  script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout\n```\n\n## ❓[Node.js Event Loop](Node.js-Event-Loop)\n\n## ❓[Vue 异步更新 (Event loop 与 Vue nextTick)](<../Vue-异步更新-(Event-loop-与-Vue-nextTick)>>)\n",data={title:"Event Loop-事件循环",DateStarted:new Date(16704576e5),tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/data-fetching/event-loop-事件循环.md",rawData:void 0},html='<h1 id="event-loop-事件循环">Event Loop-事件循环<a class="anchor" href="#event-loop-事件循环"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="what-is-javascript">What is JavaScript?<a class="anchor" href="#what-is-javascript"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>[How JavaScript works](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a> <a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a>)</li>\n<li>A <strong>single-threaded</strong> non-blocking asynchronous concurrent language.</li>\n<li>单线程、无阻塞、异步、并发</li>\n<li>Have <strong>a call stack</strong>, an event loop, a callback queue and other APIs…</li>\n</ul>\n<h3 id="v8">V8<a class="anchor" href="#v8"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>A JS runtime</li>\n<li>Have a callstack and a heap</li>\n<li>The V8 can do one thing at a time, but not the browser which can access other APIs.</li>\n</ul>\n<h2 id="event-loop-事件轮询机制">Event Loop (事件轮询机制)<a class="anchor" href="#event-loop-事件轮询机制"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="macrotask-的本质">macrotask 的本质<a class="anchor" href="#macrotask-的本质"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p><a href="https://github.com/frontend9/fe9-library/issues/160">深入浏览器事件循环的本质 · Issue #160 · frontend9/fe9-library · GitHub</a></p>\n<blockquote>\n<p>macrotask 本质上是浏览器多个线程之间通信的一个消息队列<br>\n在 chrome 里，每个页面都对应一个进程，该进程又有多个线程，比如 js 线程、渲染线程、io 线程、网络线程、定时器线程等，这些线程之间的通信，是通过向对方的任务队列中添加一个任务（PostTask）来实现的。</p>\n</blockquote>\n<h3 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>⭐<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube</a></li>\n<li>⭐<a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame, … - YouTube</a></li>\n<li>[这一次，彻底弄懂 JavaScript 执行机制](<a href="https://juejin.cn/post/6844903512845860872">https://juejin.cn/post/6844903512845860872</a> <a href="https://juejin.cn/post/6844903512845860872">https://juejin.cn/post/6844903512845860872</a>)</li>\n<li>[从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5</a> <a href="https://github.com/aooy/blog/issues/5">https://github.com/aooy/blog/issues/5</a>)</li>\n<li>[【THE LAST TIME】彻底吃透 JavaScript 执行机制](<a href="https://juejin.cn/post/6844903955286196237">https://juejin.cn/post/6844903955286196237</a> <a href="https://juejin.cn/post/6844903955286196237">https://juejin.cn/post/6844903955286196237</a>)</li>\n<li>[一次弄懂 Event Loop（彻底解决此类面试问题）](<a href="https://juejin.cn/post/6844903764202094606">https://juejin.cn/post/6844903764202094606</a> <a href="https://juejin.cn/post/6844903764202094606">https://juejin.cn/post/6844903764202094606</a>)</li>\n<li>[深入理解 JavaScript Event Loop](<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323">https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323</a> <a href="https://zhuanlan.zhihu.com/p/34229323">https://zhuanlan.zhihu.com/p/34229323</a>)</li>\n</ul>\n<h3 id="event-loop-execution-process">Event Loop Execution Process<a class="anchor" href="#event-loop-execution-process"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>\n<p>call stack > Web APIs > callback queue > 🔁event loop > task in callback queue? push task to the end of stack</p>\n</li>\n<li>\n<p>调用栈、堆栈溢出（stack overflow）、回调队列/任务队列（回调函数）、事件循环、</p>\n</li>\n<li>\n<p>render queue：重绘</p>\n<p><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/Pasted-image-20221208182251.png" alt=""></p>\n</li>\n</ul>\n<h4 id="事件轮询机制执行过程">事件轮询机制执行过程<a class="anchor" href="#事件轮询机制执行过程"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>1）代码执行过程中，宏任务和微任务放在不同的任务队列中<br>\n2）当某个宏任务执行完后,会查看微任务队列是否有任务。如果有，执行微任务队列中的所有微任务 (注意这里是执行所有的微任务)<br>\n3）微任务执行完成后，会读取宏任务队列中排在最前的第一个宏任务（注意宏任务是一个个取），执行该宏任务，如果执行过程中，遇到微任务，依次加入微任务队列<br>\n4）宏任务执行完成后，再次读取微任务队列里的任务，依次类推。</p>\n<h3 id="宏任务-微任务">宏任务 微任务<a class="anchor" href="#宏任务-微任务"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>宏任务是一个个执行，执行一个宏任务，然后就把在任务队列中的所有微任务都执行完，再执行下一个宏任务，再执行所有微任务，依次类推</p>\n<h3 id="reference-1">Reference<a class="anchor" href="#reference-1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>[Tasks, microtasks, queues and schedules](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F">https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F</a> <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a>)</li>\n<li><a href="https://juejin.cn/post/7020710294083092493">详解宏任务、微任务与事件循环 Event Loop - 掘金</a></li>\n</ul>\n<h3 id="宏任务macrotasks">宏任务（Macrotasks）<a class="anchor" href="#宏任务macrotasks"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务</p>\n<ul>\n<li>script 全部代码（注意同步代码也属于宏任务）</li>\n<li>setTimeout、setInterval、setImmediate 等</li>\n</ul>\n<h3 id="微任务microtasks">微任务（Microtasks）<a class="anchor" href="#微任务microtasks"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>不进入主线程、而进入 微任务列表 的任务</p>\n<ul>\n<li>Promise、MutationObserver</li>\n</ul>\n<h3 id="event-loop-与-浏览器更新渲染时机">Event loop 与 浏览器更新渲染时机<a class="anchor" href="#event-loop-与-浏览器更新渲染时机"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即 <code>宏任务 → 微任务 → 渲染更新</code>（先宏任务 再微任务，然后再渲染更新）<br>\n2）宏任务队列中，如果有大量任务等待执行时，将 <code>dom的变动作为微任务，能更快的将变化呈现给用户</code>，这样就可以在这一次的事件轮询中更新 dom</p>\n<h2 id="requestanimationframe"><code>requestAnimationFrame</code><a class="anchor" href="#requestanimationframe"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li><a href="https://juejin.cn/post/6991297852462858277?searchId=202402181438115229F57507550A5779CE">【今天你更博学了么】一个神奇的前端动画 API requestAnimationFrame - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7190728064458817591?searchId=202402181438115229F57507550A5779CE">性能优化之通俗易懂学习 requestAnimationFrame 和使用场景举例 - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7274346507037016104?searchId=202402181438115229F57507550A5779CE">另一种渲染大量数据的高效方法：requestAnimationFrame - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7262900590937063482?searchId=202402181438115229F57507550A5779CE">利用 requestAnimationFrame 优化大数据列表渲染 - 掘金</a></li>\n</ul>\n<h2 id="️-interview-exercise">🛠️ Interview Exercise<a class="anchor" href="#️-interview-exercise"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="event-loop-经典题目判断打印结果">Event Loop 经典题目：判断打印结果<a class="anchor" href="#event-loop-经典题目判断打印结果"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">()</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise0);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise5);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(timer1);</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise2);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise4);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(timer2);</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise3);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise1);</span></span>\n<span class="line"><span style="color:#E1E4E8">});</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(start);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3</span></span>\n<span class="line"></span></code></pre>\n<h4 id="事件轮询执行时机">事件轮询执行时机<a class="anchor" href="#事件轮询执行时机"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>async 隐式返回 Promise，会产生一个微任务，await 后面的代码是在微任务时执行</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(script start);</span></span>\n<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> async1</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">\tawait</span><span style="color:#B392F0"> async2</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// await 隐式返回promise</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(async1 end); </span><span style="color:#6A737D">// 这里的执行时机：在执行微任务时执行</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> async2</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(async2 end); </span><span style="color:#6A737D">// 这里是同步代码</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#B392F0">async1</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(setTimeout);</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 这里是同步代码</span></span>\n<span class="line"><span style="color:#B392F0">\tresolve</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise1);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise2);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(script end);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// 打印结果:  script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout</span></span>\n<span class="line"></span></code></pre>\n<h2 id="nodejs-event-loop">❓<a href="Node.js-Event-Loop">Node.js Event Loop</a><a class="anchor" href="#nodejs-event-loop"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="vue-异步更新-event-loop-与-vue-nexttickvue-异步更新-event-loop-与-vue-nexttick">❓[Vue 异步更新 (Event loop 与 Vue nextTick)](&#x3C;../Vue-异步更新-(Event-loop-与-Vue-nextTick)>>)<a class="anchor" href="#vue-异步更新-event-loop-与-vue-nexttickvue-异步更新-event-loop-与-vue-nexttick"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>',frontmatter={tags:["JavaScript"],Datereviewed:"2024-02-18T00:00:00.000Z",comment:null,type:"D",title:"Event Loop-事件循环",DateStarted:"2022-12-08T00:00:00.000Z",DateModified:"2024-04-18T00:00:00.000Z",status:null,difficulty:"Hard",reviewed:2,topic:["Async"],category:"Programming",minutes:6,words:1128},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/data-fetching/event-loop-事件循环.md",url=void 0;function rawContent(){return"\n# Event Loop-事件循环\n\n## What is JavaScript?\n\n- [How JavaScript works](https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5 https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n- A **single-threaded** non-blocking asynchronous concurrent language.\n- 单线程、无阻塞、异步、并发\n- Have **a call stack**, an event loop, a callback queue and other APIs...\n\n### V8\n\n- A JS runtime\n- Have a callstack and a heap\n- The V8 can do one thing at a time, but not the browser which can access other APIs.\n\n## Event Loop (事件轮询机制)\n\n### macrotask 的本质\n\n[深入浏览器事件循环的本质 · Issue #160 · frontend9/fe9-library · GitHub](https://github.com/frontend9/fe9-library/issues/160)\n\n> macrotask 本质上是浏览器多个线程之间通信的一个消息队列  \n> 在 chrome 里，每个页面都对应一个进程，该进程又有多个线程，比如 js 线程、渲染线程、io 线程、网络线程、定时器线程等，这些线程之间的通信，是通过向对方的任务队列中添加一个任务（PostTask）来实现的。\n\n### Reference\n\n- ⭐[What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube](https://www.youtube.com/watch?v=8aGhZQkoFbQ)\n- ⭐[Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame, ... - YouTube](https://www.youtube.com/watch?v=cCOL7MC4Pl0)\n- [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872 https://juejin.cn/post/6844903512845860872)\n- [从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5 https://github.com/aooy/blog/issues/5)\n- [【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237 https://juejin.cn/post/6844903955286196237)\n- [一次弄懂 Event Loop（彻底解决此类面试问题）](https://juejin.cn/post/6844903764202094606 https://juejin.cn/post/6844903764202094606)\n- [深入理解 JavaScript Event Loop](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323 https://zhuanlan.zhihu.com/p/34229323)\n\n### Event Loop Execution Process\n\n- call stack > Web APIs > callback queue > 🔁event loop > task in callback queue? push task to the end of stack\n- 调用栈、堆栈溢出（stack overflow）、回调队列/任务队列（回调函数）、事件循环、\n- render queue：重绘\n\n  ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/Pasted-image-20221208182251.png)\n\n#### 事件轮询机制执行过程\n\n1）代码执行过程中，宏任务和微任务放在不同的任务队列中  \n2）当某个宏任务执行完后,会查看微任务队列是否有任务。如果有，执行微任务队列中的所有微任务 (注意这里是执行所有的微任务)  \n3）微任务执行完成后，会读取宏任务队列中排在最前的第一个宏任务（注意宏任务是一个个取），执行该宏任务，如果执行过程中，遇到微任务，依次加入微任务队列  \n4）宏任务执行完成后，再次读取微任务队列里的任务，依次类推。\n\n### 宏任务 微任务\n\n宏任务是一个个执行，执行一个宏任务，然后就把在任务队列中的所有微任务都执行完，再执行下一个宏任务，再执行所有微任务，依次类推\n\n### Reference\n\n- [Tasks, microtasks, queues and schedules](https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n- [详解宏任务、微任务与事件循环 Event Loop - 掘金](https://juejin.cn/post/7020710294083092493)\n\n### 宏任务（Macrotasks）\n\n主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务\n\n- script 全部代码（注意同步代码也属于宏任务）\n- setTimeout、setInterval、setImmediate 等\n\n### 微任务（Microtasks）\n\n不进入主线程、而进入 微任务列表 的任务\n\n- Promise、MutationObserver\n\n### Event loop 与 浏览器更新渲染时机\n\n1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即 `宏任务 → 微任务 → 渲染更新`（先宏任务 再微任务，然后再渲染更新）  \n2）宏任务队列中，如果有大量任务等待执行时，将 `dom的变动作为微任务，能更快的将变化呈现给用户`，这样就可以在这一次的事件轮询中更新 dom\n\n## `requestAnimationFrame`\n\n- [【今天你更博学了么】一个神奇的前端动画 API requestAnimationFrame - 掘金](https://juejin.cn/post/6991297852462858277?searchId=202402181438115229F57507550A5779CE)\n- [性能优化之通俗易懂学习 requestAnimationFrame 和使用场景举例 - 掘金](https://juejin.cn/post/7190728064458817591?searchId=202402181438115229F57507550A5779CE)\n- [另一种渲染大量数据的高效方法：requestAnimationFrame - 掘金](https://juejin.cn/post/7274346507037016104?searchId=202402181438115229F57507550A5779CE)\n- [利用 requestAnimationFrame 优化大数据列表渲染 - 掘金](https://juejin.cn/post/7262900590937063482?searchId=202402181438115229F57507550A5779CE)\n\n## 🛠️ Interview Exercise\n\n#### Event Loop 经典题目：判断打印结果\n\n```javascript\nPromise.resolve()\n\t.then(function () {\n\t\tconsole.log(promise0);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise5);\n\t});\nsetTimeout(() => {\n\tconsole.log(timer1);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise2);\n\t});\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise4);\n\t});\n}, 0);\nsetTimeout(() => {\n\tconsole.log(timer2);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise3);\n\t});\n}, 0);\nPromise.resolve().then(function () {\n\tconsole.log(promise1);\n});\nconsole.log(start);\n\n// 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3\n```\n\n#### 事件轮询执行时机\n\nasync 隐式返回 Promise，会产生一个微任务，await 后面的代码是在微任务时执行\n\n```javascript\nconsole.log(script start);\nasync function async1() {\n\tawait async2(); // await 隐式返回promise\n\tconsole.log(async1 end); // 这里的执行时机：在执行微任务时执行\n}\nasync function async2() {\n\tconsole.log(async2 end); // 这里是同步代码\n}\nasync1();\nsetTimeout(function () {\n\tconsole.log(setTimeout);\n}, 0);\nnew Promise((resolve) => {\n\tconsole.log(Promise); // 这里是同步代码\n\tresolve();\n})\n\t.then(function () {\n\t\tconsole.log(promise1);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise2);\n\t});\nconsole.log(script end);\n\n// 打印结果:  script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout\n```\n\n## ❓[Node.js Event Loop](Node.js-Event-Loop)\n\n## ❓[Vue 异步更新 (Event loop 与 Vue nextTick)](<../Vue-异步更新-(Event-loop-与-Vue-nextTick)>>)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"event-loop-事件循环",text:"Event Loop-事件循环#"},{depth:2,slug:"what-is-javascript",text:"What is JavaScript?#"},{depth:3,slug:"v8",text:"V8#"},{depth:2,slug:"event-loop-事件轮询机制",text:"Event Loop (事件轮询机制)#"},{depth:3,slug:"macrotask-的本质",text:"macrotask 的本质#"},{depth:3,slug:"reference",text:"Reference#"},{depth:3,slug:"event-loop-execution-process",text:"Event Loop Execution Process#"},{depth:4,slug:"事件轮询机制执行过程",text:"事件轮询机制执行过程#"},{depth:3,slug:"宏任务-微任务",text:"宏任务 微任务#"},{depth:3,slug:"reference-1",text:"Reference#"},{depth:3,slug:"宏任务macrotasks",text:"宏任务（Macrotasks）#"},{depth:3,slug:"微任务microtasks",text:"微任务（Microtasks）#"},{depth:3,slug:"event-loop-与-浏览器更新渲染时机",text:"Event loop 与 浏览器更新渲染时机#"},{depth:2,slug:"requestanimationframe",text:"requestAnimationFrame#"},{depth:2,slug:"️-interview-exercise",text:"🛠️ Interview Exercise#"},{depth:4,slug:"event-loop-经典题目判断打印结果",text:"Event Loop 经典题目：判断打印结果#"},{depth:4,slug:"事件轮询执行时机",text:"事件轮询执行时机#"},{depth:2,slug:"nodejs-event-loop",text:"❓Node.js Event Loop#"},{depth:2,slug:"vue-异步更新-event-loop-与-vue-nexttickvue-异步更新-event-loop-与-vue-nexttick",text:"❓[Vue 异步更新 (Event loop 与 Vue nextTick)](<../Vue-异步更新-(Event-loop-与-Vue-nextTick)>>)#"}]}const Content=createComponent(((n,s,e)=>{const{layout:o,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),eventLoop_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,eventLoop_____,id,slug};