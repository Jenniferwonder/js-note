import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/oop/prototype-pattern-原型模式.md",collection="posts",slug="js/oop/prototype-pattern-原型模式",body="\n# Prototype Pattern-原型模式\n\n---\n\nBasic\n\n### 理解原型 (`prototype`, `__proto__`, `prototype.constructor`)\n\nBack:\n\n#### `prototype` 属性\n\n- 构造函数通过 prototype 属性链接到原型对象\n  - `Person.prototype.sayName = function() {   console.log(this.name);  };`\n  - 每个函数都会创建一个\n  - 是通过调用构造函数创建的对象的原型\n- 包含应被实例共享的属性和方法\n  - `prototype.constructor` 属性\n    - 所有原型对象自动获得\n    - 指回与之关联的构造函数\n    - `构造函数.prototype.constructor === 该构造函数本身`\n  - `prototype.isPrototypeOf()`\n    - `console.log(Person.prototype.isPrototypeOf(person1));  // true`\n\n#### `__proto__` 属性\n\n- 实例通过 `__proto__` 链接到构造函数原型对象\n  - 实例的内部 `[[Prototype]]` 指针就会被赋值为构造函数的原型对象\n- 通过这个属性可以访问对象的原型\n  - Object 原型的原型是 null: `Object.prototype.__proto__ === null`\n  - 正常的原型链都会终止于 Object 的原型对象 `Object.prototype`\n\n#### 特殊原型对象\n\n- [SpecialPrototype.js](file:///e%3A/SynologyDrive/TechSkills/JS/B-JS/ProJS-Code/Chapter8ObjectsClassesAndObjectOrientedProgramming/ObjectCreation/ThePrototypePattern/SpecialPrototype.js)\n\n```javascript\nconsole.log(Function.prototype === Function.__proto__); // true\nconsole.log(Object.__proto__ === Function.prototype); // true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n- ![](<https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/z-Prototype-Pattern-(原型模式).png>)  \n📌: JS::JS-Objects  \n🏷️: JS-Objects\n\x3c!--ID: 1706946593114--\x3e\n\n---\n\n### 属性遮蔽与 delete 操作符\n\n- 属性在实例上存在，所以就不会再搜索原型对象了\n  - 只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问\n- delete 操作符\n  - 可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象\n\n### 原型的动态性\n\n- 任何时候对原型对象所做的修改也会在实例上反映\n- 所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法\n\n### 重写原型\n\n#### 以对象字面量方式创建原型方法会破坏之前的原型链\n\n- `Person.prototype = {`\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/b24562708490c8c760d324ea010575ff.png)\n- 这样重写之后，`Person.prototype` 的 `constructor` 属性就不指向 Person 了\n- 重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型\n  - 实例只有指向原型的指针，没有指向构造函数的指针\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1880ffbe51fc5a18d9a461a92a14da6e.png)\n\n#### 恢复 `constructor` 属性\n\n- 原生 `constructor` 属性默认是不可枚举的\n  - `Object.defineProperty(Person.prototype, constructor, {`\n\n---\n\nBasic\n\n### 读取原型\n\nBack:\n\n- `Object.getPrototypeOf(Instance) === Instance.__proto__` \\* `console.log(Object.getPrototypeOf(person1) == Person.prototype);  // true`\n\x3c!--ID: 1706946593127--\x3e\n\n---\n\n---\n\nBasic\n\n### 设置原型\n\nBack:\n\n- ❌`Object.setPrototypeOf()`\n  - `Object.setPrototypeOf(person, biped);`\n  - 向实例的私有特性`[[Prototype]]`写入一个新值\n  - 会涉及所有访问了那些修改过`[[Prototype]]`的对象的代码\n- `Object.create()`\n  - 创建一个新对象，同时为其指定原型\n  - `let person = Object.create(biped); `\n- `Object.assign(Person.prototype, personPrototype);` \\* **methods** are defined on the prototype, but data **properties** are defined in the constructor.\n\x3c!--ID: 1706946593138--\x3e\n\n---\n",data={title:"Prototype Pattern-原型模式",DateStarted:new Date(17064864e5),tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/oop/prototype-pattern-原型模式.md",rawData:void 0},html='<h1 id="prototype-pattern-原型模式">Prototype Pattern-原型模式<a class="anchor" href="#prototype-pattern-原型模式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<hr>\n<p>Basic</p>\n<h3 id="理解原型-prototype-__proto__-prototypeconstructor">理解原型 (<code>prototype</code>, <code>__proto__</code>, <code>prototype.constructor</code>)<a class="anchor" href="#理解原型-prototype-__proto__-prototypeconstructor"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<h4 id="prototype-属性"><code>prototype</code> 属性<a class="anchor" href="#prototype-属性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>构造函数通过 prototype 属性链接到原型对象\n<ul>\n<li><code>Person.prototype.sayName = function() {   console.log(this.name);  };</code></li>\n<li>每个函数都会创建一个</li>\n<li>是通过调用构造函数创建的对象的原型</li>\n</ul>\n</li>\n<li>包含应被实例共享的属性和方法\n<ul>\n<li><code>prototype.constructor</code> 属性\n<ul>\n<li>所有原型对象自动获得</li>\n<li>指回与之关联的构造函数</li>\n<li><code>构造函数.prototype.constructor === 该构造函数本身</code></li>\n</ul>\n</li>\n<li><code>prototype.isPrototypeOf()</code>\n<ul>\n<li><code>console.log(Person.prototype.isPrototypeOf(person1));  // true</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="__proto__-属性"><code>__proto__</code> 属性<a class="anchor" href="#__proto__-属性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>实例通过 <code>__proto__</code> 链接到构造函数原型对象\n<ul>\n<li>实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象</li>\n</ul>\n</li>\n<li>通过这个属性可以访问对象的原型\n<ul>\n<li>Object 原型的原型是 null: <code>Object.prototype.__proto__ === null</code></li>\n<li>正常的原型链都会终止于 Object 的原型对象 <code>Object.prototype</code></li>\n</ul>\n</li>\n</ul>\n<h4 id="特殊原型对象">特殊原型对象<a class="anchor" href="#特殊原型对象"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><a href="file:///e%3A/SynologyDrive/TechSkills/JS/B-JS/ProJS-Code/Chapter8ObjectsClassesAndObjectOrientedProgramming/ObjectCreation/ThePrototypePattern/SpecialPrototype.js">SpecialPrototype.js</a></li>\n</ul>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#F97583"> ===</span><span style="color:#E1E4E8"> Function.</span><span style="color:#79B8FF">__proto__</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(Object.</span><span style="color:#79B8FF">__proto__</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">__proto__</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> Object</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Object</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">__proto__</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span>\n<span class="line"></span></code></pre>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/z-Prototype-Pattern-(原型模式).png" alt=""><br>\n📌: JS::JS-Objects<br>\n🏷️: JS-Objects</li>\n</ul>\n\x3c!--ID: 1706946593114--\x3e\n<hr>\n<h3 id="属性遮蔽与-delete-操作符">属性遮蔽与 delete 操作符<a class="anchor" href="#属性遮蔽与-delete-操作符"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>属性在实例上存在，所以就不会再搜索原型对象了\n<ul>\n<li>只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问</li>\n</ul>\n</li>\n<li>delete 操作符\n<ul>\n<li>可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象</li>\n</ul>\n</li>\n</ul>\n<h3 id="原型的动态性">原型的动态性<a class="anchor" href="#原型的动态性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>任何时候对原型对象所做的修改也会在实例上反映</li>\n<li>所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法</li>\n</ul>\n<h3 id="重写原型">重写原型<a class="anchor" href="#重写原型"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="以对象字面量方式创建原型方法会破坏之前的原型链">以对象字面量方式创建原型方法会破坏之前的原型链<a class="anchor" href="#以对象字面量方式创建原型方法会破坏之前的原型链"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>Person.prototype = {</code>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/b24562708490c8c760d324ea010575ff.png" alt="image"></li>\n</ul>\n</li>\n<li>这样重写之后，<code>Person.prototype</code> 的 <code>constructor</code> 属性就不指向 Person 了</li>\n<li>重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型\n<ul>\n<li>实例只有指向原型的指针，没有指向构造函数的指针</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1880ffbe51fc5a18d9a461a92a14da6e.png" alt="image"></li>\n</ul>\n</li>\n</ul>\n<h4 id="恢复-constructor-属性">恢复 <code>constructor</code> 属性<a class="anchor" href="#恢复-constructor-属性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>原生 <code>constructor</code> 属性默认是不可枚举的\n<ul>\n<li><code>Object.defineProperty(Person.prototype, constructor, {</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>Basic</p>\n<h3 id="读取原型">读取原型<a class="anchor" href="#读取原型"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li><code>Object.getPrototypeOf(Instance) === Instance.__proto__</code> * <code>console.log(Object.getPrototypeOf(person1) == Person.prototype);  // true</code></li>\n</ul>\n\x3c!--ID: 1706946593127--\x3e\n<hr>\n<hr>\n<p>Basic</p>\n<h3 id="设置原型">设置原型<a class="anchor" href="#设置原型"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li>❌<code>Object.setPrototypeOf()</code>\n<ul>\n<li><code>Object.setPrototypeOf(person, biped);</code></li>\n<li>向实例的私有特性<code>[[Prototype]]</code>写入一个新值</li>\n<li>会涉及所有访问了那些修改过<code>[[Prototype]]</code>的对象的代码</li>\n</ul>\n</li>\n<li><code>Object.create()</code>\n<ul>\n<li>创建一个新对象，同时为其指定原型</li>\n<li><code>let person = Object.create(biped); </code></li>\n</ul>\n</li>\n<li><code>Object.assign(Person.prototype, personPrototype);</code> * <strong>methods</strong> are defined on the prototype, but data <strong>properties</strong> are defined in the constructor.</li>\n</ul>\n\x3c!--ID: 1706946593138--\x3e\n<hr>',frontmatter={aliases:["Prototype Pattern-原型模式"],title:"Prototype Pattern-原型模式",topic:["Objects"],type:"D",tags:["JavaScript"],DateStarted:"2024-01-29T00:00:00.000Z",DateModified:"2024-04-18T00:00:00.000Z",Datereviewed:"2024-02-03T00:00:00.000Z",reviewed:2,difficulty:null,status:null,comment:null,"linter-yaml-title-alias":"Prototype Pattern-原型模式",category:"Programming",minutes:3,words:628},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/oop/prototype-pattern-原型模式.md",url=void 0;function rawContent(){return"\n# Prototype Pattern-原型模式\n\n---\n\nBasic\n\n### 理解原型 (`prototype`, `__proto__`, `prototype.constructor`)\n\nBack:\n\n#### `prototype` 属性\n\n- 构造函数通过 prototype 属性链接到原型对象\n  - `Person.prototype.sayName = function() {   console.log(this.name);  };`\n  - 每个函数都会创建一个\n  - 是通过调用构造函数创建的对象的原型\n- 包含应被实例共享的属性和方法\n  - `prototype.constructor` 属性\n    - 所有原型对象自动获得\n    - 指回与之关联的构造函数\n    - `构造函数.prototype.constructor === 该构造函数本身`\n  - `prototype.isPrototypeOf()`\n    - `console.log(Person.prototype.isPrototypeOf(person1));  // true`\n\n#### `__proto__` 属性\n\n- 实例通过 `__proto__` 链接到构造函数原型对象\n  - 实例的内部 `[[Prototype]]` 指针就会被赋值为构造函数的原型对象\n- 通过这个属性可以访问对象的原型\n  - Object 原型的原型是 null: `Object.prototype.__proto__ === null`\n  - 正常的原型链都会终止于 Object 的原型对象 `Object.prototype`\n\n#### 特殊原型对象\n\n- [SpecialPrototype.js](file:///e%3A/SynologyDrive/TechSkills/JS/B-JS/ProJS-Code/Chapter8ObjectsClassesAndObjectOrientedProgramming/ObjectCreation/ThePrototypePattern/SpecialPrototype.js)\n\n```javascript\nconsole.log(Function.prototype === Function.__proto__); // true\nconsole.log(Object.__proto__ === Function.prototype); // true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n- ![](<https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/z-Prototype-Pattern-(原型模式).png>)  \n📌: JS::JS-Objects  \n🏷️: JS-Objects\n\x3c!--ID: 1706946593114--\x3e\n\n---\n\n### 属性遮蔽与 delete 操作符\n\n- 属性在实例上存在，所以就不会再搜索原型对象了\n  - 只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问\n- delete 操作符\n  - 可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象\n\n### 原型的动态性\n\n- 任何时候对原型对象所做的修改也会在实例上反映\n- 所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法\n\n### 重写原型\n\n#### 以对象字面量方式创建原型方法会破坏之前的原型链\n\n- `Person.prototype = {`\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/b24562708490c8c760d324ea010575ff.png)\n- 这样重写之后，`Person.prototype` 的 `constructor` 属性就不指向 Person 了\n- 重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型\n  - 实例只有指向原型的指针，没有指向构造函数的指针\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1880ffbe51fc5a18d9a461a92a14da6e.png)\n\n#### 恢复 `constructor` 属性\n\n- 原生 `constructor` 属性默认是不可枚举的\n  - `Object.defineProperty(Person.prototype, constructor, {`\n\n---\n\nBasic\n\n### 读取原型\n\nBack:\n\n- `Object.getPrototypeOf(Instance) === Instance.__proto__` \\* `console.log(Object.getPrototypeOf(person1) == Person.prototype);  // true`\n\x3c!--ID: 1706946593127--\x3e\n\n---\n\n---\n\nBasic\n\n### 设置原型\n\nBack:\n\n- ❌`Object.setPrototypeOf()`\n  - `Object.setPrototypeOf(person, biped);`\n  - 向实例的私有特性`[[Prototype]]`写入一个新值\n  - 会涉及所有访问了那些修改过`[[Prototype]]`的对象的代码\n- `Object.create()`\n  - 创建一个新对象，同时为其指定原型\n  - `let person = Object.create(biped); `\n- `Object.assign(Person.prototype, personPrototype);` \\* **methods** are defined on the prototype, but data **properties** are defined in the constructor.\n\x3c!--ID: 1706946593138--\x3e\n\n---\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"prototype-pattern-原型模式",text:"Prototype Pattern-原型模式#"},{depth:3,slug:"理解原型-prototype-__proto__-prototypeconstructor",text:"理解原型 (prototype, __proto__, prototype.constructor)#"},{depth:4,slug:"prototype-属性",text:"prototype 属性#"},{depth:4,slug:"__proto__-属性",text:"__proto__ 属性#"},{depth:4,slug:"特殊原型对象",text:"特殊原型对象#"},{depth:3,slug:"属性遮蔽与-delete-操作符",text:"属性遮蔽与 delete 操作符#"},{depth:3,slug:"原型的动态性",text:"原型的动态性#"},{depth:3,slug:"重写原型",text:"重写原型#"},{depth:4,slug:"以对象字面量方式创建原型方法会破坏之前的原型链",text:"以对象字面量方式创建原型方法会破坏之前的原型链#"},{depth:4,slug:"恢复-constructor-属性",text:"恢复 constructor 属性#"},{depth:3,slug:"读取原型",text:"读取原型#"},{depth:3,slug:"设置原型",text:"设置原型#"}]}const Content=createComponent(((n,o,t)=>{const{layout:e,...r}=frontmatter;return r.file=file,r.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),prototypePattern_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,prototypePattern_____,slug};