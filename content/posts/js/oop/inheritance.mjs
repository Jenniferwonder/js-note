import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/oop/inheritance.md",collection="posts",slug="js/oop/inheritance",body="\n# Inheritance-继承\n\n### OOP 语言支持的继承\n\n- 接口继承\n  - 继承方法签名（不支持）\n- 实现继承\n  - 继承实际的方法\n  - 实现继承是 ECMAScript 唯一支持的继承方式\n  - 通过原型链实现\n\n### 原型链继承\n\n- `SubType.prototype = new SuperType();`\n- 通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型\n  - 原型链扩展了前面描述的原型搜索机制\n- 任何函数的默认原型都是一个 Object 的实例\n- 子类有时候需要覆盖父类的方法，或者增加父类没有的方法\n  - 这些方法必须在原型赋值之后再添加到原型上\n  - 上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的\n\n#### 原型链的问题\n\n- 原型中包含的引用值会在所有实例间共享\n  - 所以属性通常会在构造函数中定义而不会定义在原型上\n- 弱化了向构造函数传参能力，会导致所有实例默认都取得相同的属性值\n\n### 盗用构造函数继承\n\n- 在子类构造函数中调用父类构造函数\n  - 可以使用`apply()`和`call()`方法以新创建的对象为上下文执行构造函数\n- 盗用构造函数的优点\n  - 也称作“对象伪装”或“经典继承”\n  - 可以在子类构造函数中向父类构造函数传参\n    - 实际上会在 SubType 的实例上定义`name`属性\n      - `SuperType.call(this, Nicholas);`\n\n#### 盗用构造函数的问题\n\n- 函数不能重用\n- 子类也不能访问父类原型上定义的方法\n\n### 组合继承\n\n- 也叫伪经典继承\n- ![image|375](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png)\n  - `SuperType.call(this, name);`\n  - `SubType.prototype = new SuperType();`\n\n#### 效率问题\n\n- 父类构造函数始终会被调用两次\n  - 一次在是创建子类原型时调用\n  - 另一次是在子类构造函数中调用\n- 解决方案：\n  - 🏷️ 寄生式组合继承\n\n#### 优点\n\n- 综合了原型链和盗用构造函数，将两者的优点集中了起来\n  - 使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性\n  - 保留了`instanceof`操作符和`isPrototypeOf()`方法识别合成对象的能力\n  - 使用最多的继承模式\n\n### 原型式继承\n\n- 对传入的对象执行了一次浅复制\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/761444f8eae3a55fee7209f35d52803b.png)\n- `Object.create()`\n  - 只有一个参数时，`Object.create()`与这里的`object()`方法效果相同\n  - 两个参数\n    - 作为新对象原型的对象\n    - 给新对象定义额外属性的对象（第二个可选）\n      - 第二个参数与`Object.defineProperties()`的第二个参数一样\n      - 每个新增属性都通过各自的描述符来描述\n      - 会遮蔽原型对象上的同名属性\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/0f7db5c833bd11c935753b4ac88b222f.png)\n\n#### 优缺点\n\n- 适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合\n- 属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的\n\n### ❓ 寄生式继承\n\n- 寄生构造函数和工厂模式\n  - 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象\n\n#### 缺点\n\n- 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似\n\n### ❓ 寄生式组合继承\n\n- 使用寄生式继承来继承父类原型，但使用混合式原型链继承方法\n- ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png)\n\n#### 优点\n\n- 寄生式组合继承可以算是引用类型继承的最佳模式\n  - 避免了`SubType.prototype`上不必要也用不到的属性\n\n### Reference\n\n- [Object-oriented programming - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)\n- [Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube](https://www.youtube.com/watch?v=PFmuCDHHpwk)\n\n### ❓Use Case\n",data={title:"Inheritance-继承",DateStarted:new Date(16701984e5),tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/oop/inheritance.md",rawData:void 0},html='<h1 id="inheritance-继承">Inheritance-继承<a class="anchor" href="#inheritance-继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="oop-语言支持的继承">OOP 语言支持的继承<a class="anchor" href="#oop-语言支持的继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>接口继承\n<ul>\n<li>继承方法签名（不支持）</li>\n</ul>\n</li>\n<li>实现继承\n<ul>\n<li>继承实际的方法</li>\n<li>实现继承是 ECMAScript 唯一支持的继承方式</li>\n<li>通过原型链实现</li>\n</ul>\n</li>\n</ul>\n<h3 id="原型链继承">原型链继承<a class="anchor" href="#原型链继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><code>SubType.prototype = new SuperType();</code></li>\n<li>通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型\n<ul>\n<li>原型链扩展了前面描述的原型搜索机制</li>\n</ul>\n</li>\n<li>任何函数的默认原型都是一个 Object 的实例</li>\n<li>子类有时候需要覆盖父类的方法，或者增加父类没有的方法\n<ul>\n<li>这些方法必须在原型赋值之后再添加到原型上</li>\n<li>上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的</li>\n</ul>\n</li>\n</ul>\n<h4 id="原型链的问题">原型链的问题<a class="anchor" href="#原型链的问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>原型中包含的引用值会在所有实例间共享\n<ul>\n<li>所以属性通常会在构造函数中定义而不会定义在原型上</li>\n</ul>\n</li>\n<li>弱化了向构造函数传参能力，会导致所有实例默认都取得相同的属性值</li>\n</ul>\n<h3 id="盗用构造函数继承">盗用构造函数继承<a class="anchor" href="#盗用构造函数继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>在子类构造函数中调用父类构造函数\n<ul>\n<li>可以使用<code>apply()</code>和<code>call()</code>方法以新创建的对象为上下文执行构造函数</li>\n</ul>\n</li>\n<li>盗用构造函数的优点\n<ul>\n<li>也称作“对象伪装”或“经典继承”</li>\n<li>可以在子类构造函数中向父类构造函数传参\n<ul>\n<li>实际上会在 SubType 的实例上定义<code>name</code>属性\n<ul>\n<li><code>SuperType.call(this, Nicholas);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="盗用构造函数的问题">盗用构造函数的问题<a class="anchor" href="#盗用构造函数的问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>函数不能重用</li>\n<li>子类也不能访问父类原型上定义的方法</li>\n</ul>\n<h3 id="组合继承">组合继承<a class="anchor" href="#组合继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>也叫伪经典继承</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png" alt="image|375">\n<ul>\n<li><code>SuperType.call(this, name);</code></li>\n<li><code>SubType.prototype = new SuperType();</code></li>\n</ul>\n</li>\n</ul>\n<h4 id="效率问题">效率问题<a class="anchor" href="#效率问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>父类构造函数始终会被调用两次\n<ul>\n<li>一次在是创建子类原型时调用</li>\n<li>另一次是在子类构造函数中调用</li>\n</ul>\n</li>\n<li>解决方案：\n<ul>\n<li>🏷️ 寄生式组合继承</li>\n</ul>\n</li>\n</ul>\n<h4 id="优点">优点<a class="anchor" href="#优点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>综合了原型链和盗用构造函数，将两者的优点集中了起来\n<ul>\n<li>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</li>\n<li>保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力</li>\n<li>使用最多的继承模式</li>\n</ul>\n</li>\n</ul>\n<h3 id="原型式继承">原型式继承<a class="anchor" href="#原型式继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>对传入的对象执行了一次浅复制\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/761444f8eae3a55fee7209f35d52803b.png" alt="image"></li>\n</ul>\n</li>\n<li><code>Object.create()</code>\n<ul>\n<li>只有一个参数时，<code>Object.create()</code>与这里的<code>object()</code>方法效果相同</li>\n<li>两个参数\n<ul>\n<li>作为新对象原型的对象</li>\n<li>给新对象定义额外属性的对象（第二个可选）\n<ul>\n<li>第二个参数与<code>Object.defineProperties()</code>的第二个参数一样</li>\n<li>每个新增属性都通过各自的描述符来描述</li>\n<li>会遮蔽原型对象上的同名属性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/0f7db5c833bd11c935753b4ac88b222f.png" alt="image"></li>\n</ul>\n</li>\n</ul>\n<h4 id="优缺点">优缺点<a class="anchor" href="#优缺点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</li>\n<li>属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的</li>\n</ul>\n<h3 id="-寄生式继承">❓ 寄生式继承<a class="anchor" href="#-寄生式继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>寄生构造函数和工厂模式\n<ul>\n<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</li>\n</ul>\n</li>\n</ul>\n<h4 id="缺点">缺点<a class="anchor" href="#缺点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</li>\n</ul>\n<h3 id="-寄生式组合继承">❓ 寄生式组合继承<a class="anchor" href="#-寄生式组合继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>使用寄生式继承来继承父类原型，但使用混合式原型链继承方法</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png" alt="image"></li>\n</ul>\n<h4 id="优点-1">优点<a class="anchor" href="#优点-1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>寄生式组合继承可以算是引用类型继承的最佳模式\n<ul>\n<li>避免了<code>SubType.prototype</code>上不必要也用不到的属性</li>\n</ul>\n</li>\n</ul>\n<h3 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming">Object-oriented programming - Learn web development | MDN</a></li>\n<li><a href="https://www.youtube.com/watch?v=PFmuCDHHpwk">Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube</a></li>\n</ul>\n<h3 id="use-case">❓Use Case<a class="anchor" href="#use-case"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>',frontmatter={title:"Inheritance-继承",topic:["OOP"],type:"D",tags:["JavaScript"],DateStarted:"2022-12-05T00:00:00.000Z",DateModified:"2024-04-18T00:00:00.000Z",Datereviewed:"2024-02-03T00:00:00.000Z",reviewed:0,difficulty:"Hard",status:["ToUse"],comment:null,"linter-yaml-title-alias":"Inheritance-继承",aliases:["Inheritance-继承"],category:"Programming",minutes:5,words:930},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/oop/inheritance.md",url=void 0;function rawContent(){return"\n# Inheritance-继承\n\n### OOP 语言支持的继承\n\n- 接口继承\n  - 继承方法签名（不支持）\n- 实现继承\n  - 继承实际的方法\n  - 实现继承是 ECMAScript 唯一支持的继承方式\n  - 通过原型链实现\n\n### 原型链继承\n\n- `SubType.prototype = new SuperType();`\n- 通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型\n  - 原型链扩展了前面描述的原型搜索机制\n- 任何函数的默认原型都是一个 Object 的实例\n- 子类有时候需要覆盖父类的方法，或者增加父类没有的方法\n  - 这些方法必须在原型赋值之后再添加到原型上\n  - 上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的\n\n#### 原型链的问题\n\n- 原型中包含的引用值会在所有实例间共享\n  - 所以属性通常会在构造函数中定义而不会定义在原型上\n- 弱化了向构造函数传参能力，会导致所有实例默认都取得相同的属性值\n\n### 盗用构造函数继承\n\n- 在子类构造函数中调用父类构造函数\n  - 可以使用`apply()`和`call()`方法以新创建的对象为上下文执行构造函数\n- 盗用构造函数的优点\n  - 也称作“对象伪装”或“经典继承”\n  - 可以在子类构造函数中向父类构造函数传参\n    - 实际上会在 SubType 的实例上定义`name`属性\n      - `SuperType.call(this, Nicholas);`\n\n#### 盗用构造函数的问题\n\n- 函数不能重用\n- 子类也不能访问父类原型上定义的方法\n\n### 组合继承\n\n- 也叫伪经典继承\n- ![image|375](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png)\n  - `SuperType.call(this, name);`\n  - `SubType.prototype = new SuperType();`\n\n#### 效率问题\n\n- 父类构造函数始终会被调用两次\n  - 一次在是创建子类原型时调用\n  - 另一次是在子类构造函数中调用\n- 解决方案：\n  - 🏷️ 寄生式组合继承\n\n#### 优点\n\n- 综合了原型链和盗用构造函数，将两者的优点集中了起来\n  - 使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性\n  - 保留了`instanceof`操作符和`isPrototypeOf()`方法识别合成对象的能力\n  - 使用最多的继承模式\n\n### 原型式继承\n\n- 对传入的对象执行了一次浅复制\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/761444f8eae3a55fee7209f35d52803b.png)\n- `Object.create()`\n  - 只有一个参数时，`Object.create()`与这里的`object()`方法效果相同\n  - 两个参数\n    - 作为新对象原型的对象\n    - 给新对象定义额外属性的对象（第二个可选）\n      - 第二个参数与`Object.defineProperties()`的第二个参数一样\n      - 每个新增属性都通过各自的描述符来描述\n      - 会遮蔽原型对象上的同名属性\n  - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/0f7db5c833bd11c935753b4ac88b222f.png)\n\n#### 优缺点\n\n- 适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合\n- 属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的\n\n### ❓ 寄生式继承\n\n- 寄生构造函数和工厂模式\n  - 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象\n\n#### 缺点\n\n- 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似\n\n### ❓ 寄生式组合继承\n\n- 使用寄生式继承来继承父类原型，但使用混合式原型链继承方法\n- ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png)\n\n#### 优点\n\n- 寄生式组合继承可以算是引用类型继承的最佳模式\n  - 避免了`SubType.prototype`上不必要也用不到的属性\n\n### Reference\n\n- [Object-oriented programming - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)\n- [Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube](https://www.youtube.com/watch?v=PFmuCDHHpwk)\n\n### ❓Use Case\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"inheritance-继承",text:"Inheritance-继承#"},{depth:3,slug:"oop-语言支持的继承",text:"OOP 语言支持的继承#"},{depth:3,slug:"原型链继承",text:"原型链继承#"},{depth:4,slug:"原型链的问题",text:"原型链的问题#"},{depth:3,slug:"盗用构造函数继承",text:"盗用构造函数继承#"},{depth:4,slug:"盗用构造函数的问题",text:"盗用构造函数的问题#"},{depth:3,slug:"组合继承",text:"组合继承#"},{depth:4,slug:"效率问题",text:"效率问题#"},{depth:4,slug:"优点",text:"优点#"},{depth:3,slug:"原型式继承",text:"原型式继承#"},{depth:4,slug:"优缺点",text:"优缺点#"},{depth:3,slug:"-寄生式继承",text:"❓ 寄生式继承#"},{depth:4,slug:"缺点",text:"缺点#"},{depth:3,slug:"-寄生式组合继承",text:"❓ 寄生式组合继承#"},{depth:4,slug:"优点-1",text:"优点#"},{depth:3,slug:"reference",text:"Reference#"},{depth:3,slug:"use-case",text:"❓Use Case#"}]}const Content=createComponent(((n,e,i)=>{const{layout:a,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),inheritance=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,inheritance,slug};