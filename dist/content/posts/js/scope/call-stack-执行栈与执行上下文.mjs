import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/scope/call-stack-执行栈与执行上下文.md",collection="posts",slug="js/scope/call-stack-执行栈与执行上下文",body="\n## 执行上下文\n\n> [理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181 https://juejin.cn/post/6844903682283143181) >[理解 JavaScript 的执行上下文](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F72959191 https://zhuanlan.zhihu.com/p/72959191) >[JavaScript 进阶-执行上下文](https://juejin.cn/post/6844903983438381069 https://juejin.cn/post/6844903983438381069) >[JavaScript 深入之执行上下文栈](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4 https://github.com/mqyqingfeng/Blog/issues/4) >[一道 js 面试题引发的思考 · Issue #18 · kuitos/kuitos.github.io · GitHub](https://github.com/kuitos/kuitos.github.io/issues/18)\n\n#### 1. 什么是执行上下文？\n\nJavascript 代码都是在 **执行上下文** 中运行的  \n执行上下文： 指当前执行环境中的变量、函数声明、作用域链 [Scope-作用域](Scope-作用域)、this 等信息\n\n#### 2. 执行上下文生命周期\n\n##### 2.1. 创建阶段\n\n生成变量对象、建立作用域链 [Scope-作用域](Scope-作用域)、确定 this 的指向\n\n##### 2.2. 执行阶段\n\n变量赋值、函数的引用、执行其他代码  \n![执行上下文.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f02e41f0bff3498990d04b7c90215a1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n##### 2.3. 变量对象\n\n变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明  \n变量对象是一个抽象的概念，在全局执行上下文中，变量对象就是全局对象。\n\n#### 3. 执行上下文的特点：\n\n1. 单线程，只在主线程上运行；\n2. 同步执行，从上向下按顺序执行；\n3. 全局上下文只有一个，也就是 `window` 对象；\n4. 函数每调用一次就会产生一个新的执行上下文环境。\n\n#### 4. 全局、函数、Eval 执行上下文\n\n执行上下文分为 `全局、函数、Eval执行上下文`\n\n1. 全局执行上下文（浏览器环境下，为全局的 `window` 对象）\n2. 函数执行上下文，每当一个函数被调用时, 都会为该函数创建一个新的上下文\n3. 🟨Eval 函数执行上下文，如 eval(1 + 2)  \n   对于每个执行上下文，都有三个重要属性：变量对象、作用域链 ([Scope-作用域](Scope-作用域) chain)、this`\n\n## 执行栈 Call Stack\n\n是一种 `先进后出` 的数据结构，用来存储代码运行的所有执行上下文\n\n1. 当 JS 引擎第一次遇到 `.js` 脚本时，会创建一个全局的执行上下文并且压入当前执行栈\n2. 每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部\n3. 当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文\n4. 一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文\n\n### 执行栈示例\n\n```php\nvar a = 1; // 1. 全局上下文环境\nfunction bar (x) {\n    console.log('bar')\n    var b = 2;\n    fn(x + b); // 3. fn上下文环境\n}\nfunction fn (c) {\n    console.log(c);\n}\nbar(3); // 2. bar上下文环境\n\n```\n\n**执行栈图解** ![执行上下文.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bffb09739624bcdb3572c6ae963d8a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n",data={title:"Call Stack-执行栈与执行上下文",DateStarted:new Date(16711488e5),tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/scope/call-stack-执行栈与执行上下文.md",rawData:void 0},html='<h2 id="执行上下文">执行上下文<a class="anchor" href="#执行上下文"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<blockquote>\n<p>[理解 JavaScript 中的执行上下文和执行栈](<a href="https://juejin.cn/post/6844903682283143181">https://juejin.cn/post/6844903682283143181</a> <a href="https://juejin.cn/post/6844903682283143181">https://juejin.cn/post/6844903682283143181</a>) >[理解 JavaScript 的执行上下文](<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F72959191">https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F72959191</a> <a href="https://zhuanlan.zhihu.com/p/72959191">https://zhuanlan.zhihu.com/p/72959191</a>) >[JavaScript 进阶-执行上下文](<a href="https://juejin.cn/post/6844903983438381069">https://juejin.cn/post/6844903983438381069</a> <a href="https://juejin.cn/post/6844903983438381069">https://juejin.cn/post/6844903983438381069</a>) >[JavaScript 深入之执行上下文栈](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4">https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4</a> <a href="https://github.com/mqyqingfeng/Blog/issues/4">https://github.com/mqyqingfeng/Blog/issues/4</a>) ><a href="https://github.com/kuitos/kuitos.github.io/issues/18">一道 js 面试题引发的思考 · Issue #18 · kuitos/kuitos.github.io · GitHub</a></p>\n</blockquote>\n<h4 id="1-什么是执行上下文">1. 什么是执行上下文？<a class="anchor" href="#1-什么是执行上下文"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>Javascript 代码都是在 <strong>执行上下文</strong> 中运行的<br>\n执行上下文： 指当前执行环境中的变量、函数声明、作用域链 <a href="Scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope-作用域</a>、this 等信息</p>\n<h4 id="2-执行上下文生命周期">2. 执行上下文生命周期<a class="anchor" href="#2-执行上下文生命周期"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h5 id="21-创建阶段">2.1. 创建阶段<a class="anchor" href="#21-创建阶段"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>生成变量对象、建立作用域链 <a href="Scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope-作用域</a>、确定 this 的指向</p>\n<h5 id="22-执行阶段">2.2. 执行阶段<a class="anchor" href="#22-执行阶段"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>变量赋值、函数的引用、执行其他代码<br>\n<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f02e41f0bff3498990d04b7c90215a1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="执行上下文.jpg"></p>\n<h5 id="23-变量对象">2.3. 变量对象<a class="anchor" href="#23-变量对象"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明<br>\n变量对象是一个抽象的概念，在全局执行上下文中，变量对象就是全局对象。</p>\n<h4 id="3-执行上下文的特点">3. 执行上下文的特点：<a class="anchor" href="#3-执行上下文的特点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ol>\n<li>单线程，只在主线程上运行；</li>\n<li>同步执行，从上向下按顺序执行；</li>\n<li>全局上下文只有一个，也就是 <code>window</code> 对象；</li>\n<li>函数每调用一次就会产生一个新的执行上下文环境。</li>\n</ol>\n<h4 id="4-全局函数eval-执行上下文">4. 全局、函数、Eval 执行上下文<a class="anchor" href="#4-全局函数eval-执行上下文"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>执行上下文分为 <code>全局、函数、Eval执行上下文</code></p>\n<ol>\n<li>全局执行上下文（浏览器环境下，为全局的 <code>window</code> 对象）</li>\n<li>函数执行上下文，每当一个函数被调用时, 都会为该函数创建一个新的上下文</li>\n<li>🟨Eval 函数执行上下文，如 eval(1 + 2)<br>\n对于每个执行上下文，都有三个重要属性：变量对象、作用域链 (<a href="Scope-%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope-作用域</a> chain)、this`</li>\n</ol>\n<h2 id="执行栈-call-stack">执行栈 Call Stack<a class="anchor" href="#执行栈-call-stack"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>是一种 <code>先进后出</code> 的数据结构，用来存储代码运行的所有执行上下文</p>\n<ol>\n<li>当 JS 引擎第一次遇到 <code>.js</code> 脚本时，会创建一个全局的执行上下文并且压入当前执行栈</li>\n<li>每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部</li>\n<li>当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</li>\n<li>一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文</li>\n</ol>\n<h3 id="执行栈示例">执行栈示例<a class="anchor" href="#执行栈示例"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#79B8FF"> a</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// 1. 全局上下文环境</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> bar</span><span style="color:#E1E4E8"> (x) {</span></span>\n<span class="line"><span style="color:#79B8FF">    console</span><span style="color:#F97583">.</span><span style="color:#79B8FF">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">\'bar\'</span><span style="color:#E1E4E8">)</span></span>\n<span class="line"><span style="color:#F97583">    var</span><span style="color:#79B8FF"> b</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">    fn</span><span style="color:#E1E4E8">(x + b); // 3. fn上下文环境</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#E1E4E8">function fn (c) {</span></span>\n<span class="line"><span style="color:#E1E4E8">    console.log(c);</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#E1E4E8">bar(3); // 2. bar上下文环境</span></span>\n<span class="line"></span>\n<span class="line"></span></code></pre>\n<p><strong>执行栈图解</strong> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bffb09739624bcdb3572c6ae963d8a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="执行上下文.png"></p>',frontmatter={title:"Call Stack-执行栈与执行上下文",topic:["Scope"],tags:["JavaScript"],type:"D",DateStarted:"2022-12-16T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",Datereviewed:null,comment:null,reviewed:null,difficulty:null,status:null,category:"Programming",minutes:3,words:687},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/scope/call-stack-执行栈与执行上下文.md",url=void 0;function rawContent(){return"\n## 执行上下文\n\n> [理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181 https://juejin.cn/post/6844903682283143181) >[理解 JavaScript 的执行上下文](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F72959191 https://zhuanlan.zhihu.com/p/72959191) >[JavaScript 进阶-执行上下文](https://juejin.cn/post/6844903983438381069 https://juejin.cn/post/6844903983438381069) >[JavaScript 深入之执行上下文栈](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4 https://github.com/mqyqingfeng/Blog/issues/4) >[一道 js 面试题引发的思考 · Issue #18 · kuitos/kuitos.github.io · GitHub](https://github.com/kuitos/kuitos.github.io/issues/18)\n\n#### 1. 什么是执行上下文？\n\nJavascript 代码都是在 **执行上下文** 中运行的  \n执行上下文： 指当前执行环境中的变量、函数声明、作用域链 [Scope-作用域](Scope-作用域)、this 等信息\n\n#### 2. 执行上下文生命周期\n\n##### 2.1. 创建阶段\n\n生成变量对象、建立作用域链 [Scope-作用域](Scope-作用域)、确定 this 的指向\n\n##### 2.2. 执行阶段\n\n变量赋值、函数的引用、执行其他代码  \n![执行上下文.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f02e41f0bff3498990d04b7c90215a1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n##### 2.3. 变量对象\n\n变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明  \n变量对象是一个抽象的概念，在全局执行上下文中，变量对象就是全局对象。\n\n#### 3. 执行上下文的特点：\n\n1. 单线程，只在主线程上运行；\n2. 同步执行，从上向下按顺序执行；\n3. 全局上下文只有一个，也就是 `window` 对象；\n4. 函数每调用一次就会产生一个新的执行上下文环境。\n\n#### 4. 全局、函数、Eval 执行上下文\n\n执行上下文分为 `全局、函数、Eval执行上下文`\n\n1. 全局执行上下文（浏览器环境下，为全局的 `window` 对象）\n2. 函数执行上下文，每当一个函数被调用时, 都会为该函数创建一个新的上下文\n3. 🟨Eval 函数执行上下文，如 eval(1 + 2)  \n   对于每个执行上下文，都有三个重要属性：变量对象、作用域链 ([Scope-作用域](Scope-作用域) chain)、this`\n\n## 执行栈 Call Stack\n\n是一种 `先进后出` 的数据结构，用来存储代码运行的所有执行上下文\n\n1. 当 JS 引擎第一次遇到 `.js` 脚本时，会创建一个全局的执行上下文并且压入当前执行栈\n2. 每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部\n3. 当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文\n4. 一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文\n\n### 执行栈示例\n\n```php\nvar a = 1; // 1. 全局上下文环境\nfunction bar (x) {\n    console.log('bar')\n    var b = 2;\n    fn(x + b); // 3. fn上下文环境\n}\nfunction fn (c) {\n    console.log(c);\n}\nbar(3); // 2. bar上下文环境\n\n```\n\n**执行栈图解** ![执行上下文.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bffb09739624bcdb3572c6ae963d8a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:2,slug:"执行上下文",text:"执行上下文#"},{depth:4,slug:"1-什么是执行上下文",text:"1. 什么是执行上下文？#"},{depth:4,slug:"2-执行上下文生命周期",text:"2. 执行上下文生命周期#"},{depth:5,slug:"21-创建阶段",text:"2.1. 创建阶段#"},{depth:5,slug:"22-执行阶段",text:"2.2. 执行阶段#"},{depth:5,slug:"23-变量对象",text:"2.3. 变量对象#"},{depth:4,slug:"3-执行上下文的特点",text:"3. 执行上下文的特点：#"},{depth:4,slug:"4-全局函数eval-执行上下文",text:"4. 全局、函数、Eval 执行上下文#"},{depth:2,slug:"执行栈-call-stack",text:"执行栈 Call Stack#"},{depth:3,slug:"执行栈示例",text:"执行栈示例#"}]}const Content=createComponent(((n,a,t)=>{const{layout:s,...e}=frontmatter;return e.file=file,e.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),callStack__________=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,callStack__________,collection,data,id,slug};