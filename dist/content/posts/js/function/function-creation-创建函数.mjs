import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/function/function-creation-创建函数.md",collection="posts",slug="js/function/function-creation-创建函数",body="\n---\n\nBasic\n\n### 创建函数的方法\n\nBack:\n\n#### 函数声明\n\n- `function sum (num1, num2) {`\n\n#### 函数表达式\n\n- `let sum = function (num1, num2) {`\n- 这样创建的函数叫作匿名函数（anonymous funtion）\n  - 兰姆达函数\n  - 未赋值给其他变量的匿名函数的 name 属性是空字符串\n\n#### 箭头函数（arrow function）\n\n- `let sum = (num1, num2) ={`\n- 没有参数，或者多个参数的情况下，才需要使用括号\n- 不使用大括号\n  - 箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式\n  - 会隐式返回这行代码的值\n- 使用大括号\n  - 包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样\n\n#### 构造函数\n\n- `let sum = new Function(num1, num2, return num1 + num2);  // 不推荐`\n- 最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数\n📌: JS::JS-Function\n🏷️: JS-Function\n\x3c!--ID: 1708054155507--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数声明与函数表达式区别\n\nBack:\n\n- 函数声明提升（function declaration hoisting）\n  - 即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部\n- 函数表达式要先赋值再使用 - 函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义\n\x3c!--ID: 1708054155517--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数表达式适用场景\n\nBack:\n\n- 根据 condition 的值为变量 sayHi 赋予相应的函数\n- 在一个函数中把另一个函数当作值返回 - `return function(object1, object2) {`\n\x3c!--ID: 1708054155527--\x3e\n\n---\n\n---\n\nBasic\n\n### 箭头函数适用与不适用场景\n\nBack:\n\n- 适合嵌入函数的场景，作为回调函数\n  - `console.log(ints.map((i) ={ return i + 1 }));`\n- 不适用的场合 - 不能使用 `arguments`、`super` 和 `new.target` - 不能用作构造函数 - 没有 `prototype` 属性 - `this` 指向父级对象或函数，而非函数本身\n\x3c!--ID: 1708054155535--\x3e\n\n---\n",data={title:"Function Creation (创建函数)",DateStarted:new Date(17071776e5),tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/function/function-creation-创建函数.md",rawData:void 0},html='<hr>\n<p>Basic</p>\n<h3 id="创建函数的方法">创建函数的方法<a class="anchor" href="#创建函数的方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<h4 id="函数声明">函数声明<a class="anchor" href="#函数声明"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>function sum (num1, num2) {</code></li>\n</ul>\n<h4 id="函数表达式">函数表达式<a class="anchor" href="#函数表达式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = function (num1, num2) {</code></li>\n<li>这样创建的函数叫作匿名函数（anonymous funtion）\n<ul>\n<li>兰姆达函数</li>\n<li>未赋值给其他变量的匿名函数的 name 属性是空字符串</li>\n</ul>\n</li>\n</ul>\n<h4 id="箭头函数arrow-function">箭头函数（arrow function）<a class="anchor" href="#箭头函数arrow-function"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = (num1, num2) ={</code></li>\n<li>没有参数，或者多个参数的情况下，才需要使用括号</li>\n<li>不使用大括号\n<ul>\n<li>箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式</li>\n<li>会隐式返回这行代码的值</li>\n</ul>\n</li>\n<li>使用大括号\n<ul>\n<li>包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样</li>\n</ul>\n</li>\n</ul>\n<h4 id="构造函数">构造函数<a class="anchor" href="#构造函数"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = new Function(num1, num2, return num1 + num2);  // 不推荐</code></li>\n<li>最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数\n📌: JS::JS-Function\n🏷️: JS-Function</li>\n</ul>\n\x3c!--ID: 1708054155507--\x3e\n<hr>\n<hr>\n<p>Basic</p>\n<h3 id="函数声明与函数表达式区别">函数声明与函数表达式区别<a class="anchor" href="#函数声明与函数表达式区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li>函数声明提升（function declaration hoisting）\n<ul>\n<li>即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部</li>\n</ul>\n</li>\n<li>函数表达式要先赋值再使用 - 函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义</li>\n</ul>\n\x3c!--ID: 1708054155517--\x3e\n<hr>\n<hr>\n<p>Basic</p>\n<h3 id="函数表达式适用场景">函数表达式适用场景<a class="anchor" href="#函数表达式适用场景"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li>根据 condition 的值为变量 sayHi 赋予相应的函数</li>\n<li>在一个函数中把另一个函数当作值返回 - <code>return function(object1, object2) {</code></li>\n</ul>\n\x3c!--ID: 1708054155527--\x3e\n<hr>\n<hr>\n<p>Basic</p>\n<h3 id="箭头函数适用与不适用场景">箭头函数适用与不适用场景<a class="anchor" href="#箭头函数适用与不适用场景"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li>适合嵌入函数的场景，作为回调函数\n<ul>\n<li><code>console.log(ints.map((i) ={ return i + 1 }));</code></li>\n</ul>\n</li>\n<li>不适用的场合 - 不能使用 <code>arguments</code>、<code>super</code> 和 <code>new.target</code> - 不能用作构造函数 - 没有 <code>prototype</code> 属性 - <code>this</code> 指向父级对象或函数，而非函数本身</li>\n</ul>\n\x3c!--ID: 1708054155535--\x3e\n<hr>',frontmatter={title:"Function Creation (创建函数)",topic:["Function"],type:"D",tags:["JavaScript"],DateStarted:"2024-02-06T00:00:00.000Z",DateModified:"2024-04-18T00:00:00.000Z",Datereviewed:"2024-02-16T00:00:00.000Z",reviewed:3,difficulty:null,status:null,comment:null,category:"Programming",minutes:2,words:473},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/function/function-creation-创建函数.md",url=void 0;function rawContent(){return"\n---\n\nBasic\n\n### 创建函数的方法\n\nBack:\n\n#### 函数声明\n\n- `function sum (num1, num2) {`\n\n#### 函数表达式\n\n- `let sum = function (num1, num2) {`\n- 这样创建的函数叫作匿名函数（anonymous funtion）\n  - 兰姆达函数\n  - 未赋值给其他变量的匿名函数的 name 属性是空字符串\n\n#### 箭头函数（arrow function）\n\n- `let sum = (num1, num2) ={`\n- 没有参数，或者多个参数的情况下，才需要使用括号\n- 不使用大括号\n  - 箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式\n  - 会隐式返回这行代码的值\n- 使用大括号\n  - 包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样\n\n#### 构造函数\n\n- `let sum = new Function(num1, num2, return num1 + num2);  // 不推荐`\n- 最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数\n📌: JS::JS-Function\n🏷️: JS-Function\n\x3c!--ID: 1708054155507--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数声明与函数表达式区别\n\nBack:\n\n- 函数声明提升（function declaration hoisting）\n  - 即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部\n- 函数表达式要先赋值再使用 - 函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义\n\x3c!--ID: 1708054155517--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数表达式适用场景\n\nBack:\n\n- 根据 condition 的值为变量 sayHi 赋予相应的函数\n- 在一个函数中把另一个函数当作值返回 - `return function(object1, object2) {`\n\x3c!--ID: 1708054155527--\x3e\n\n---\n\n---\n\nBasic\n\n### 箭头函数适用与不适用场景\n\nBack:\n\n- 适合嵌入函数的场景，作为回调函数\n  - `console.log(ints.map((i) ={ return i + 1 }));`\n- 不适用的场合 - 不能使用 `arguments`、`super` 和 `new.target` - 不能用作构造函数 - 没有 `prototype` 属性 - `this` 指向父级对象或函数，而非函数本身\n\x3c!--ID: 1708054155535--\x3e\n\n---\n"}function compiledContent(){return html}function getHeadings(){return[{depth:3,slug:"创建函数的方法",text:"创建函数的方法#"},{depth:4,slug:"函数声明",text:"函数声明#"},{depth:4,slug:"函数表达式",text:"函数表达式#"},{depth:4,slug:"箭头函数arrow-function",text:"箭头函数（arrow function）#"},{depth:4,slug:"构造函数",text:"构造函数#"},{depth:3,slug:"函数声明与函数表达式区别",text:"函数声明与函数表达式区别#"},{depth:3,slug:"函数表达式适用场景",text:"函数表达式适用场景#"},{depth:3,slug:"箭头函数适用与不适用场景",text:"箭头函数适用与不适用场景#"}]}const Content=createComponent(((n,t,e)=>{const{layout:o,...i}=frontmatter;return i.file=file,i.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),functionCreation_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,functionCreation_____,id,slug};