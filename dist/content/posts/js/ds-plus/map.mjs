import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/ds-plus/map.md",collection="posts",slug="js/ds-plus/map",body="\n# Map\n\n## 创建方式\n\n- 构造函数\n  - `const m = new Map()`\n- 构造函数参数（初始化实例）\n  - 嵌套数组\n  - 自定义迭代器 iterator\n  - 空数组\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691557774350.png)\n  - 在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时 仍然保持不变\n  - delete()和 clear()\n  - size 属性\n  - set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询\n  - 使用严格对象相等的标准来检查键的匹配性\n  - 与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序\n  - set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明\n  - 迭代操作\n  - alert(m.entries === m[Symbol.iterator]); // true\n  - Symbol.iterator 属性\n  - entries()方法\n  - console.log([...m]); // [key1,val1],[key2,val2],[key3,val3](key1,val1],[key2,val2],[key3,val3)\n  - forEach(callback, opt_thisArg)\n  - 传入的回调接收可选的第二个参数，这个参数用于重写回调 内部 this 的值\n  - keys()和 values()\n  - 键和值在迭代器遍历时是可以修改的\n\n## 选择 Object 还是 Map\n\n- Map 大约可以比 Object 多存储 50%的键/值对\n- 内存占用\n- 插入性能\n- 查找速度\n- 删除性能\n- 插入 Map 在所有浏览器中一般会稍微快 一点儿\n- 如果只包含少量键/值对， 则 Object 有时候速度更快。\n- Map 的 delete()操作都比插入和查找更快\n",data={title:"Map",DateStarted:new Date(16905888e5),draft:!0,tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/ds-plus/map.md",rawData:void 0},html='<h1 id="map">Map<a class="anchor" href="#map"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="创建方式">创建方式<a class="anchor" href="#创建方式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>构造函数\n<ul>\n<li><code>const m = new Map()</code></li>\n</ul>\n</li>\n<li>构造函数参数（初始化实例）\n<ul>\n<li>嵌套数组</li>\n<li>自定义迭代器 iterator</li>\n<li>空数组</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691557774350.png" alt=""></li>\n<li>在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时 仍然保持不变</li>\n<li>delete()和 clear()</li>\n<li>size 属性</li>\n<li>set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询</li>\n<li>使用严格对象相等的标准来检查键的匹配性</li>\n<li>与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序</li>\n<li>set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明</li>\n<li>迭代操作</li>\n<li>alert(m.entries === m[Symbol.iterator]); // true</li>\n<li>Symbol.iterator 属性</li>\n<li>entries()方法</li>\n<li>console.log([…m]); // [key1,val1],[key2,val2],<a href="key1,val1%5D,%5Bkey2,val2%5D,%5Bkey3,val3">key3,val3</a></li>\n<li>forEach(callback, opt_thisArg)</li>\n<li>传入的回调接收可选的第二个参数，这个参数用于重写回调 内部 this 的值</li>\n<li>keys()和 values()</li>\n<li>键和值在迭代器遍历时是可以修改的</li>\n</ul>\n</li>\n</ul>\n<h2 id="选择-object-还是-map">选择 Object 还是 Map<a class="anchor" href="#选择-object-还是-map"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>Map 大约可以比 Object 多存储 50%的键/值对</li>\n<li>内存占用</li>\n<li>插入性能</li>\n<li>查找速度</li>\n<li>删除性能</li>\n<li>插入 Map 在所有浏览器中一般会稍微快 一点儿</li>\n<li>如果只包含少量键/值对， 则 Object 有时候速度更快。</li>\n<li>Map 的 delete()操作都比插入和查找更快</li>\n</ul>',frontmatter={title:"Map",type:"D",DateStarted:"2023-07-29T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",status:"Snooze",Pages:6,Up:[["C06-Collection Reference Type-集合引用类型"]],Pomo:1,topic:["DS+"],category:"Programming",tags:["JavaScript"],draft:!0,minutes:2,words:335},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/ds-plus/map.md",url=void 0;function rawContent(){return"\n# Map\n\n## 创建方式\n\n- 构造函数\n  - `const m = new Map()`\n- 构造函数参数（初始化实例）\n  - 嵌套数组\n  - 自定义迭代器 iterator\n  - 空数组\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691557774350.png)\n  - 在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时 仍然保持不变\n  - delete()和 clear()\n  - size 属性\n  - set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询\n  - 使用严格对象相等的标准来检查键的匹配性\n  - 与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序\n  - set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明\n  - 迭代操作\n  - alert(m.entries === m[Symbol.iterator]); // true\n  - Symbol.iterator 属性\n  - entries()方法\n  - console.log([...m]); // [key1,val1],[key2,val2],[key3,val3](key1,val1],[key2,val2],[key3,val3)\n  - forEach(callback, opt_thisArg)\n  - 传入的回调接收可选的第二个参数，这个参数用于重写回调 内部 this 的值\n  - keys()和 values()\n  - 键和值在迭代器遍历时是可以修改的\n\n## 选择 Object 还是 Map\n\n- Map 大约可以比 Object 多存储 50%的键/值对\n- 内存占用\n- 插入性能\n- 查找速度\n- 删除性能\n- 插入 Map 在所有浏览器中一般会稍微快 一点儿\n- 如果只包含少量键/值对， 则 Object 有时候速度更快。\n- Map 的 delete()操作都比插入和查找更快\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"map",text:"Map#"},{depth:2,slug:"创建方式",text:"创建方式#"},{depth:2,slug:"选择-object-还是-map",text:"选择 Object 还是 Map#"}]}const Content=createComponent(((e,n,t)=>{const{layout:l,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),map=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,map,slug};